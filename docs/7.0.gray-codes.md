Here is the complete treatment for **Chapter 7 â€“ Gray Codes** from *Combinatorial Algorithms for Computers and Calculators* by Nijenhuis and Wilf.

---

## ðŸ“˜ Chapter 7: Gray Codes

---

### ðŸ” **Main Ideas**

This chapter covers the construction of **Gray codes** â€” sequences of combinatorial objects (typically binary strings or subsets) where successive items differ in a small and controlled way, usually by a single bit or element.

Key ideas:

* Binary reflected Gray codes
* Loopless generation
* Gray codes for combinations, permutations, and other structures
* Hamiltonian paths on the Boolean cube

---

## âœ… **Step 1: Chapter Summary with Algorithm Descriptions**

---

### âš™ï¸ **7.1 Binary Reflected Gray Code (BRGC)**

**Goal**: Generate all ( 2^n ) binary strings of length ( n ) such that successive strings differ in exactly one bit.

**Recursive Definition**:

* Base case: ( G_1 = [0, 1] )
* For ( G_n ), prepend 0 to ( G_{n-1} ), then 1 to the reverse of ( G_{n-1} )

**Example**:
For ( n = 2 ):

```
00  
01  
11  
10  
```

**Complexity**: ( O(1) ) change per code; ( O(2^n) ) time

---

### ðŸ”„ **7.2 Loopless Gray Code for Binary Strings**

**Goal**: Generate Gray code without recursion or stack, in constant time per step.

**Method**:

* Use a control array to track positions
* Based on Ehrlichâ€™s algorithm for loopless Gray codes

---

### ðŸ§® **7.3 Gray Code for k-Subsets**

**Goal**: Generate all size-( k ) subsets of ( {1, 2, ..., n} ) such that successive subsets differ in one element.

**Method**:

* Recursive or loopless approach
* Can be derived from binary reflected Gray code restricted to words with ( k ) ones

---

## âœ¨ **Step 2: CLRS-style Pseudocode**

---

### 7.1 BINARY-REFLECTED-GRAY-CODE

```plaintext
BRGC(n)
1. if n == 0: return [""]
2. R â† BRGC(n - 1)
3. return ["0" + x for x in R] + ["1" + x for x in reverse(R)]
```

---

### 7.2 LOOPLESS-BRGC (Ehrlich's)

```plaintext
LOOPLESS-GRAY(n)
1. A â† [0, 0, ..., 0] of length n
2. P â† [0, 1, ..., n]
3. repeat
4.     OUTPUT A
5.     i â† 1
6.     while P[i] == 0: P[i] â† i; i â† i + 1
7.     if i == n + 1: break
8.     P[i] â† P[i] - 1
9.     A[i - 1] â† 1 - A[i - 1]
```

---

### 7.3 GRAY-CODE-K-SUBSETS

```plaintext
GRAY-K-SUBSETS(n, k)
1. Let A be the first k-set: [0, 1, ..., k-1]
2. repeat
3.     OUTPUT A
4.     Generate next subset differing by 1 element (e.g., using Chaseâ€™s algorithm)
5. until all subsets are generated
```

---

## ðŸ¦€ **Step 3: Rust Implementation**

---

### `gray/binary.rs`

```rust
pub fn binary_reflected_gray(n: usize) -> Vec<String> {
    if n == 0 {
        return vec!["".to_string()];
    }
    let prev = binary_reflected_gray(n - 1);
    let mut result = vec![];
    for s in &prev {
        result.push(format!("0{}", s));
    }
    for s in prev.iter().rev() {
        result.push(format!("1{}", s));
    }
    result
}
```

---

### `gray/loopless.rs` (Ehrlich's algorithm)

```rust
pub fn loopless_gray(n: usize) -> Vec<Vec<u8>> {
    let mut a = vec![0; n];
    let mut p = (0..=n).collect::<Vec<_>>();
    let mut result = vec![a.clone()];

    loop {
        let mut i = 1;
        while p[i] == 0 {
            p[i] = i;
            i += 1;
        }
        if i == n + 1 {
            break;
        }
        p[i] -= 1;
        a[i - 1] ^= 1;
        result.push(a.clone());
    }

    result
}
```

---

### `gray/k_subsets.rs`

```rust
pub fn gray_k_subsets(n: usize, k: usize) -> Vec<Vec<usize>> {
    let mut result = vec![];
    let mut x = (0..k).collect::<Vec<_>>();

    fn chase_next(x: &mut Vec<usize>, n: usize, k: usize) -> bool {
        for i in (0..k).rev() {
            if x[i] != i + n - k {
                x[i] += 1;
                for j in i+1..k {
                    x[j] = x[j-1] + 1;
                }
                return true;
            }
        }
        false
    }

    result.push(x.clone());
    while chase_next(&mut x, n, k) {
        result.push(x.clone());
    }

    result
}
```

---

### âœ… Tests

```rust
#[cfg(test)]
mod tests {
    use super::binary::*;
    use super::loopless::*;
    use super::k_subsets::*;

    #[test]
    fn test_brgc() {
        let codes = binary_reflected_gray(3);
        assert_eq!(codes.len(), 8);
        assert_eq!(codes[0], "000");
        assert_eq!(codes[1], "001");
        assert_eq!(codes[2], "011");
        assert_eq!(codes[3], "010");
        assert_eq!(codes[4], "110");
        assert_eq!(codes[5], "111");
        assert_eq!(codes[6], "101");
        assert_eq!(codes[7], "100");
    }

    #[test]
    fn test_loopless_gray() {
        let codes = loopless_gray(3);
        assert_eq!(codes.len(), 8);
        for i in 1..codes.len() {
            let diff = codes[i].iter().zip(&codes[i-1])
                .filter(|(a, b)| a != b)
                .count();
            assert_eq!(diff, 1);
        }
    }

    #[test]
    fn test_k_gray_subsets() {
        let codes = gray_k_subsets(4, 2);
        assert_eq!(codes.len(), 6); // C(4, 2)
        assert!(codes.contains(&vec![0,1]));
        assert!(codes.contains(&vec![1,3]));
    }
}
```

---
