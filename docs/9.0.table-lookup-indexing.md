Here is the complete treatment for **Chapter 9 â€“ Table Lookup and Indexing Algorithms** from *Combinatorial Algorithms for Computers and Calculators* by Nijenhuis and Wilf.

---

## ðŸ“˜ Chapter 9: Table Lookup and Indexing Algorithms

---

### ðŸ” **Main Ideas**

This chapter explores efficient methods for:

* **Indexing** combinatorial objects (mapping objects to integers)
* **Table lookups** using compact and constant-time representations
* Designing **perfect hash functions** and fast lookup techniques for known sets
* Applications to combinations, permutations, and multiset configurations

The chapter builds on ranking/unranking techniques and extends them to fast runtime structures (like hash tables or indexed arrays) where space and speed tradeoffs are important.

---

## âœ… **Step 1: Chapter Summary with Algorithm Descriptions**

---

### ðŸ§® **9.1 Indexing Combinatorial Objects**

**Goal**: Map combinatorial objects (permutations, combinations, etc.) to unique integers and vice versa (ranking/unranking).

**Approach**:

* Use ranking functions discussed in earlier chapters
* These rank functions act as **injective hash functions**

**Objects covered**:

* Permutations (via Lehmer code)
* Combinations (via lexicographic rank)
* Set partitions (Stirling-based ranks)

---

### ðŸ“¦ **9.2 Table Lookup Optimization**

**Goal**: Store large but known static sets of combinatorial objects for **O(1)** access

**Methods**:

* Use direct address tables when size is manageable
* Use space-efficient encoding like tries or prefix trees
* Use perfect hash functions when direct addressing is too large

---

### ðŸ” **9.3 Perfect Hash Functions**

**Goal**: Compute collision-free hash functions for fixed sets of known keys

**Method**:

* Use precomputed ranks for perfect hashing
* For example, a rank of a combination or permutation can serve as a perfect hash

---

### ðŸ“‹ **9.4 Table Compression**

**Goal**: Store large tables (e.g., all combinations) in compressed form while allowing fast random access

**Techniques**:

* Compress using shared prefixes (tries)
* Store differences between entries
* Use canonical encodings and reconstruct on-the-fly

---

## âœ¨ **Step 2: CLRS-style Abstract Pseudocode**

---

### 9.1 RANK-OBJECT

```plaintext
RANK-OBJECT(obj)
1. return rank_function(obj)
```

---

### 9.2 LOOKUP-TABLE-ACCESS

```plaintext
LOOKUP-TABLE(index)
1. return table[index]
```

---

### 9.3 PERFECT-HASH

```plaintext
PERFECT-HASH(obj)
1. return RANK-OBJECT(obj)
```

---

### 9.4 COMPRESSED-TABLE-ACCESS

```plaintext
ACCESS-COMPRESSED(index)
1. Navigate trie or delta structure to reconstruct object at index
2. return object
```

---

## ðŸ¦€ **Step 3: Rust Implementation**

---

### `table/rank.rs`

Reuses ranking functions from combinations, permutations, etc.

```rust
pub fn perfect_hash_combination(c: &[usize], n: usize) -> usize {
    crate::combinations::ranking::rank_comb(c, n)
}

pub fn perfect_hash_permutation(p: &[usize]) -> usize {
    crate::ranking::rank_perm(p)
}
```

---

### `table/lookup.rs`

```rust
pub fn lookup_table<T: Clone>(table: &[T], index: usize) -> Option<T> {
    table.get(index).cloned()
}
```

---

### `table/compress.rs`

Simple prefix-compressed lookup structure (trie-like):

```rust
use std::collections::HashMap;

#[derive(Default)]
pub struct CompressedTable {
    pub children: HashMap<u8, CompressedTable>,
    pub value: Option<Vec<u8>>,
}

impl CompressedTable {
    pub fn insert(&mut self, key: &[u8], value: Vec<u8>) {
        let mut node = self;
        for &byte in key {
            node = node.children.entry(byte).or_default();
        }
        node.value = Some(value);
    }

    pub fn get(&self, key: &[u8]) -> Option<&Vec<u8>> {
        let mut node = self;
        for &byte in key {
            node = node.children.get(&byte)?;
        }
        node.value.as_ref()
    }
}
```

---

### âœ… Tests

```rust
#[cfg(test)]
mod tests {
    use super::rank::*;
    use super::lookup::*;
    use super::compress::*;

    #[test]
    fn test_perfect_hash_comb() {
        let c = vec![1, 3, 4];
        let r = perfect_hash_combination(&c, 6);
        assert_eq!(r, crate::combinations::ranking::rank_comb(&c, 6));
    }

    #[test]
    fn test_lookup_table() {
        let table = vec!["zero", "one", "two"];
        assert_eq!(lookup_table(&table, 1), Some("one"));
        assert_eq!(lookup_table(&table, 5), None);
    }

    #[test]
    fn test_compressed_table() {
        let mut trie = CompressedTable::default();
        trie.insert(b"abc", b"value1".to_vec());
        trie.insert(b"abd", b"value2".to_vec());

        assert_eq!(trie.get(b"abc").unwrap(), b"value1");
        assert_eq!(trie.get(b"abd").unwrap(), b"value2");
        assert_eq!(trie.get(b"ab").is_none(), true);
    }
}
```

---
