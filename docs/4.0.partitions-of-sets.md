Here is the full treatment of **Chapter 4 ‚Äì Partitions of a Set** from *Combinatorial Algorithms for Computers and Calculators* by Nijenhuis and Wilf.

---

## üìò **Chapter 4: Partitions of a Set**

---

### üîç **Main Ideas**

This chapter deals with *set partitions*: ways to divide a set of ( n ) elements into nonempty, disjoint subsets (called blocks), such that every element is in exactly one block.

Key highlights:

* Bell numbers count the total number of set partitions.
* Stirling numbers of the second kind count the number of partitions into ( k ) blocks.
* Algorithms generate all partitions or fixed-k partitions in a canonical order.
* Ranking and unranking based on a recursive structure.

---

## ‚úÖ **Step 1: Chapter Summary with Algorithm Descriptions**

---

### üì¶ **4.1 Canonical Set Partition Generator**

**Goal**: Generate all set partitions of ( {1, ..., n} ).

**Representation**: As an array ( A[1..n] ) where ( A[i] ) is the block number of element ( i ). First occurrence of a block uses the smallest available integer label.

**Algorithm** (recursive backtracking):

* For element ( i ), assign it to any existing block ( \leq m ), or create a new one ( m+1 )
* Recurse with updated max block label

**Output**: All ( B_n ) partitions (Bell number)

**Complexity**: ( O(n \cdot B_n) )

---

### üî¢ **4.2 Fixed-Size Set Partitions (k blocks)**

**Goal**: Generate all partitions of ( n ) elements into exactly ( k ) blocks.

**Method**: Same as above, but constrain the number of blocks to never exceed ( k ). Prune branches accordingly.

**Complexity**: ( O(n \cdot S(n, k)) ) where ( S(n, k) ) is the Stirling number of the second kind.

---

### üßÆ **4.3 Rank and Unrank Set Partitions**

**Goal**: Assign a unique index to each partition and retrieve it efficiently.

**Ranking idea**:

* Use recurrence based on how the next element joins a block:
  [
  S(n, k) = k \cdot S(n - 1, k) + S(n - 1, k - 1)
  ]

**Unranking**:

* Reconstruct element-by-element using recurrence table ( S(n, k) )

---

## ‚ú® **Step 2: CLRS-Style Pseudocode**

---

### 4.1 GENERATE-SET-PARTITIONS

```plaintext
GEN-SET-PARTITIONS(A, i, m, n)
1. if i = n
2.     output A
3. else
4.     for j = 0 to m
5.         A[i] ‚Üê j
6.         GEN-SET-PARTITIONS(A, i+1, max(m, j+1), n)
```

*Initial call: A[0] = 0, then GEN-SET-PARTITIONS(A, 1, 1, n)*

---

### 4.2 GEN-FIXED-K-SET-PARTITIONS

```plaintext
GEN-FIXED-K-PARTITIONS(A, i, m, n, k)
1. if i = n
2.     if m = k
3.         output A
4. else
5.     for j = 0 to min(m, k - 1)
6.         A[i] ‚Üê j
7.         GEN-FIXED-K-PARTITIONS(A, i+1, max(m, j+1), n, k)
```

---

### 4.3 RANK-SET-PARTITION

```plaintext
RANK-SET-PARTITION(P, n)
1. r ‚Üê 0
2. k ‚Üê 1
3. for i = 1 to n - 1
4.     if P[i] < current max block
5.         r += P[i] * S(n - i - 1, k)
6.     else
7.         r += k * S(n - i - 1, k)
8.         k += 1
9. return r
```

---

### 4.3 UNRANK-SET-PARTITION

```plaintext
UNRANK-SET-PARTITION(n, rank)
1. A ‚Üê [0]
2. k ‚Üê 1
3. for i = 1 to n - 1
4.     for j = 0 to k
5.         if j < k: x ‚Üê j * S(n - i - 1, k)
6.         else:     x ‚Üê k * S(n - i - 1, k)
7.         if x ‚â§ rank
8.             rank -= x
9.         else
10.            if j = k: k += 1
11.            A[i] ‚Üê j
12.            break
13. return A
```

---

## ü¶Ä **Step 3: Rust Implementation**

---

### `partition_set/gen.rs`

```rust
pub fn gen_set_partitions(n: usize) -> Vec<Vec<usize>> {
    let mut result = vec![];
    let mut a = vec![0; n];
    fn recurse(a: &mut [usize], i: usize, m: usize, n: usize, out: &mut Vec<Vec<usize>>) {
        if i == n {
            out.push(a.to_vec());
        } else {
            for j in 0..=m {
                a[i] = j;
                recurse(a, i + 1, m.max(j + 1), n, out);
            }
        }
    }
    recurse(&mut a, 1, 1, n, &mut result);
    result
}
```

---

### `partition_set/fixed_k.rs`

```rust
pub fn gen_k_partitions(n: usize, k: usize) -> Vec<Vec<usize>> {
    let mut result = vec![];
    let mut a = vec![0; n];
    fn recurse(a: &mut [usize], i: usize, m: usize, n: usize, k: usize, out: &mut Vec<Vec<usize>>) {
        if i == n {
            if m == k {
                out.push(a.to_vec());
            }
        } else {
            for j in 0..k.min(m + 1) {
                a[i] = j;
                recurse(a, i + 1, m.max(j + 1), n, k, out);
            }
        }
    }
    recurse(&mut a, 1, 1, n, k, &mut result);
    result
}
```

---

### `partition_set/rank.rs`

```rust
pub fn stirling(n: usize, k: usize) -> usize {
    let mut s = vec![vec![0; k + 2]; n + 2];
    s[0][0] = 1;
    for i in 1..=n {
        for j in 1..=k {
            s[i][j] = j * s[i - 1][j] + s[i - 1][j - 1];
        }
    }
    s[n][k]
}

pub fn rank_set_partition(p: &[usize], n: usize) -> usize {
    let mut rank = 0;
    let mut k = 1;
    for i in 1..n {
        let max = *p[0..i].iter().max().unwrap();
        if p[i] <= max {
            rank += p[i] * stirling(n - i - 1, k);
        } else {
            rank += k * stirling(n - i - 1, k);
            k += 1;
        }
    }
    rank
}
```

```rust
pub fn unrank_set_partition(n: usize, mut rank: usize) -> Vec<usize> {
    let mut a = vec![0];
    let mut k = 1;
    for i in 1..n {
        let mut found = false;
        for j in 0..=k {
            let x = if j < k {
                j * stirling(n - i - 1, k)
            } else {
                k * stirling(n - i - 1, k)
            };
            if x <= rank {
                rank -= x;
            } else {
                if j == k { k += 1; }
                a.push(j);
                found = true;
                break;
            }
        }
        if !found { panic!("Invalid rank"); }
    }
    a
}
```

---

### ‚úÖ Tests

```rust
#[cfg(test)]
mod tests {
    use super::gen::*;
    use super::fixed_k::*;
    use super::rank::*;

    #[test]
    fn test_gen_set_partitions() {
        let parts = gen_set_partitions(3);
        assert_eq!(parts.len(), 5); // B(3) = 5
    }

    #[test]
    fn test_fixed_k_partitions() {
        let parts = gen_k_partitions(3, 2);
        assert_eq!(parts.len(), 3); // S(3,2) = 3
    }

    #[test]
    fn test_rank_unrank_partition() {
        let p = vec![0, 1, 0];
        let r = rank_set_partition(&p, 3);
        let u = unrank_set_partition(3, r);
        assert_eq!(p, u);
    }
}
```

---
