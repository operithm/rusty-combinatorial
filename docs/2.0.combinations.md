Here is the full treatment for **Chapter 2 â€“ Combinations** from *Combinatorial Algorithms for Computers and Calculators* by Nijenhuis and Wilf:

---

## ğŸ“˜ **Chapter 2: Combinations**

---

### ğŸ” **Main Ideas**

This chapter focuses on generating and indexing *k-element subsets* (combinations) of an ( n )-element set. Key themes include:

* Lexicographic generation of combinations
* Efficient unranking and ranking
* Gray code generation for combinations
* Applications in enumeration and random sampling

---

## âœ… **Step 1: Chapter Summary with Algorithm Descriptions**

---

### ğŸ”¢ **2.1 Lexicographic Combination Generation**

**Goal**: Generate all ( \binom{n}{k} ) combinations in lexicographic order.

**Algorithm**:

* Initialize with the smallest combination: ( [0, 1, 2, ..., k-1] )
* To get the next combination:

    1. Find the rightmost index ( i ) where ( C[i] \neq n - k + i )
    2. Increment ( C[i] )
    3. Set each ( C[j] = C[i] + (j - i) ) for ( j > i )

**Complexity**: ( O(k) ) per combination

---

### ğŸ§® **2.2 Unranking of Combinations**

**Goal**: Construct the ( r )-th ( k )-subset in lexicographic order.

**Idea**: Count how many combinations precede a potential element using binomial coefficients.

**Algorithm**:

* For each position ( i ), try increasing values ( x )
* Add ( \binom{n - x - 1}{k - i - 1} ) until the cumulative sum reaches or exceeds ( r )

**Complexity**: ( O(n) ); uses Pascal triangle/binomial table

---

### ğŸ§® **2.3 Ranking of Combinations**

**Goal**: Compute the lexicographic rank of a given combination.

**Algorithm**:

* For each position ( i ), add ( \binom{n - x_i - 1}{k - i - 1} ) for values skipped before ( x_i )

**Complexity**: ( O(k) ); inverse of unranking

---

### ğŸ” **2.4 Gray Code for Combinations**

**Goal**: Generate combinations such that successive combinations differ by only one element.

**Method**: Loopless binary reflected Gray code adapted for k-combinations.

**Application**: Ideal for hardware, low-overhead enumeration.

---

### ğŸ² **2.5 Random Combination**

**Goal**: Generate a random ( k )-subset from ( {0, ..., n - 1} ) uniformly.

**Method**: Reservoir sampling or select ( k ) distinct random numbers and sort.

**Complexity**: ( O(k \log k) ) or ( O(n) ) with optimized sampling

---

## âœ¨ **Step 2: CLRS-style Abstract Model Pseudocode**

---

### 2.1 NEXT-COMBINATION

```plaintext
NEXT-COMBINATION(C, n, k)
1. for i â† k - 1 downto 0
2.     if C[i] â‰  n - k + i
3.         C[i] â† C[i] + 1
4.         for j â† i + 1 to k - 1
5.             C[j] â† C[j - 1] + 1
6.         return C
7. return NIL // last combination reached
```

---

### 2.2 UNRANK-COMBINATION

```plaintext
UNRANK-COMBINATION(n, k, r)
1. C â† empty array of length k
2. x â† 0
3. for i â† 0 to k - 1
4.     while binom(n - x - 1, k - i - 1) â‰¤ r
5.         r â† r - binom(n - x - 1, k - i - 1)
6.         x â† x + 1
7.     C[i] â† x
8.     x â† x + 1
9. return C
```

---

### 2.3 RANK-COMBINATION

```plaintext
RANK-COMBINATION(C, n, k)
1. r â† 0
2. prev â† -1
3. for i â† 0 to k - 1
4.     for x â† prev + 1 to C[i] - 1
5.         r â† r + binom(n - x - 1, k - i - 1)
6.     prev â† C[i]
7. return r
```

---

## ğŸ¦€ **Step 3: Rust Implementations**

---

### `combination::lex.rs`

```rust
pub fn next_combination(c: &mut Vec<usize>, n: usize) -> bool {
    let k = c.len();
    for i in (0..k).rev() {
        if c[i] != n - k + i {
            c[i] += 1;
            for j in i + 1..k {
                c[j] = c[j - 1] + 1;
            }
            return true;
        }
    }
    false
}
```

---

### `combination::ranking.rs`

```rust
pub fn binom(n: usize, k: usize) -> usize {
    if k > n { return 0; }
    let mut res = 1;
    for i in 0..k {
        res = res * (n - i) / (i + 1);
    }
    res
}

pub fn unrank_comb(n: usize, k: usize, mut r: usize) -> Vec<usize> {
    let mut c = Vec::with_capacity(k);
    let mut x = 0;
    for i in 0..k {
        while binom(n - x - 1, k - i - 1) <= r {
            r -= binom(n - x - 1, k - i - 1);
            x += 1;
        }
        c.push(x);
        x += 1;
    }
    c
}

pub fn rank_comb(c: &[usize], n: usize) -> usize {
    let mut r = 0;
    let mut prev = 0;
    let k = c.len();
    for (i, &val) in c.iter().enumerate() {
        for x in prev..val {
            r += binom(n - x - 1, k - i - 1);
        }
        prev = val + 1;
    }
    r
}
```

---

### `combination::random.rs`

```rust
use rand::seq::index::sample;
use rand::thread_rng;

pub fn random_combination(n: usize, k: usize) -> Vec<usize> {
    let mut indices = sample(&mut thread_rng(), n, k).into_vec();
    indices.sort();
    indices
}
```

---

### âœ… Unit Test Example

```rust
#[cfg(test)]
mod tests {
    use super::lex::*;
    use super::ranking::*;
    use super::random::*;

    #[test]
    fn test_next_comb() {
        let mut c = vec![0, 1, 2];
        assert!(next_combination(&mut c, 5));
        assert_eq!(c, vec![0, 1, 3]);
    }

    #[test]
    fn test_rank_and_unrank() {
        let c = vec![1, 3, 4];
        let r = rank_comb(&c, 6);
        let u = unrank_comb(6, 3, r);
        assert_eq!(c, u);
    }

    #[test]
    fn test_random_comb() {
        let c = random_combination(10, 4);
        assert_eq!(c.len(), 4);
        assert!(c.windows(2).all(|w| w[0] < w[1]));
    }
}
```

---
