Here is the reading summary for **Chapter 1** of *Combinatorial Algorithms for Computers and Calculators* by Nijenhuis and Wilf:

---

## ğŸ“˜ **Chapter 1: Permutations**

### ğŸ” **Main Ideas**

This chapter introduces the concept of permutations and various methods for generating them efficiently. Permutations are fundamental combinatorial objects that appear in many mathematical and computational problems. The chapter focuses on:

* Lexicographic ordering of permutations
* Mapping between permutations and integers (ranking/unranking)
* Efficient generation of permutations (both in-place and using minimal changes)

---
## âœ… **Step 1: Chapter Summary with Algorithm Descriptions**
### ğŸ”§ **Key Algorithms**

---

#### **1.1 Lexicographic Generation of Permutations**

**Goal**: Generate all ( n! ) permutations of ( {1, 2, ..., n} ) in lexicographic (dictionary) order.

**Method**:

* Start with the identity permutation ( [1, 2, ..., n] )
* Find the next permutation using the following steps:

    1. Scan from right to left to find the largest index ( i ) such that ( A[i] < A[i+1] )
    2. Find the largest index ( j > i ) such that ( A[j] > A[i] )
    3. Swap ( A[i] ) and ( A[j] )
    4. Reverse the subarray ( A[i+1:] )

**Complexity**:
Each permutation is generated in ( O(n) ) time. Efficient and standard.

---

#### **1.2 Plain Changes (Minimal Change Generation)**

**Goal**: Generate permutations such that each successive permutation differs by swapping two adjacent elements.

**Method**: Uses a clever recursive strategy:

* Think of inserting the largest number at every possible position in the permutation of ( n - 1 ) elements.
* Alternate the direction of insertions to ensure minimal change (Steinhausâ€“Johnsonâ€“Trotter-like approach).

**Key Property**: Only adjacent transpositions are used between steps.

**Complexity**: ( O(1) ) change per permutation; good for hardware or mechanical generation.

---

#### **1.3 Inversion Table / Lehmer Code**

**Goal**: Map between permutations and integers â€” supports ranking (assigning number to a permutation) and unranking (constructing a permutation from a number).

**Concept**:

* An inversion table (Lehmer code) encodes how many elements after each position are smaller than the current one.
* For example, in permutation ( P = [3, 1, 2] ), the inversion table is ( [2, 0, 0] )

**Ranking**:

* Convert permutation to its inversion table.
* Interpret inversion table as a number in mixed radix base.

**Unranking**:

* Convert number to mixed radix digits (inversion table).
* Reconstruct permutation by successive selection.

**Complexity**: ( O(n^2) ) naive; can be optimized with segment trees to ( O(n \log n) )

---

#### **1.4 Random Permutation (Uniform Sampling)**

**Goal**: Generate a uniformly random permutation.

**Method** (Fisherâ€“Yates Shuffle):

* For ( i = n ) down to ( 2 ):

    * Pick a random index ( j \in [1, i] )
    * Swap ( A[i] ) and ( A[j] )

**Complexity**: ( O(n) ); uniform and unbiased if random numbers are fair.

---

#### **1.5 Next Permutation with Constraint**

**Goal**: Given a permutation and a constraint (e.g., fixed positions), find the next permutation in lex order under the constraint.

**Method**:

* Modify the basic lexicographic algorithm to skip over permutations violating the constraint.
* More efficient than generating all permutations and filtering.

**Complexity**: Varies with constraint type; often problem-specific.

---

### ğŸ“Œ **Chapter Insights**

* The inversion table idea links permutations with number systems â€” key for efficient combinatorial indexing.
* Lexicographic and minimal-change generation serve different purposes (e.g., efficient iteration vs. minimal transitions).
* Efficient permutation handling is foundational for later topics (e.g., combinations, partitions, graphs).

---

---

## âœ… **Step 2: Abstract Model Language (CLRS-style)**

---

### ğŸ§® 1.1 Next Lexicographic Permutation

```plaintext
NEXT-LEX-PERMUTATION(A)
1. n â† length[A]
2. i â† n - 2
3. while i â‰¥ 0 and A[i] â‰¥ A[i + 1]
4.     i â† i - 1
5. if i < 0
6.     return NIL // last permutation
7. j â† n - 1
8. while A[j] â‰¤ A[i]
9.     j â† j - 1
10. swap A[i] and A[j]
11. reverse A[i + 1 .. n - 1]
12. return A
```

---

### ğŸ”„ 1.2 Minimal-Change (Plain Changes / Steinhausâ€“Johnsonâ€“Trotter)

```plaintext
GEN-MINIMAL-PERMUTATIONS(n)
1. Let A â† [1, 2, ..., n]
2. Let DIR â† array of size n, all initialized to LEFT
3. repeat
4.     OUTPUT(A)
5.     m â† largest mobile element
6.     if no mobile element
7.         return
8.     swap m with adjacent element in DIR[m] direction
9.     reverse direction of all elements > m
```

*Mobile = greater than neighbor in its direction.*

---

### ğŸ§® 1.3 Inversion Table (Lehmer Code) and Ranking

```plaintext
RANK-PERMUTATION(P)
1. n â† length[P]
2. rank â† 0
3. for i â† 0 to n - 1
4.     c â† number of entries after P[i] < P[i]
5.     rank â† rank * (n - i) + c
6. return rank
```

```plaintext
UNRANK-PERMUTATION(n, rank)
1. Let A â† [1, 2, ..., n]
2. for i from 0 to n - 1
3.     d â† rank mod (n - i)
4.     rank â† floor(rank / (n - i))
5.     P[i] â† A[d]
6.     delete A[d] from A
7. return P
```

---

### ğŸ² 1.4 Fisherâ€“Yates Shuffle

```plaintext
RANDOM-PERMUTATION(A)
1. n â† length[A]
2. for i â† n - 1 downto 1
3.     j â† RANDOM(0, i)
4.     swap A[i] and A[j]
5. return A
```

---

## ğŸ¦€ **Step 3: Rust Implementations**

```rust
/// 1.1 Next lexicographic permutation
pub fn next_lex_perm<T: Ord>(a: &mut [T]) -> bool {
    let n = a.len();
    if n < 2 { return false; }

    let mut i = n - 2;
    while i > 0 && a[i] >= a[i + 1] { i -= 1; }
    if a[i] >= a[i + 1] && i == 0 { return false; }

    let mut j = n - 1;
    while a[j] <= a[i] { j -= 1; }
    a.swap(i, j);
    a[i + 1..].reverse();
    true
}
```

```rust
/// 1.2 Steinhausâ€“Johnsonâ€“Trotter permutation generator
pub fn gen_minimal_perms(n: usize) -> Vec<Vec<usize>> {
    #[derive(Clone, Copy, PartialEq)] enum Dir { Left, Right }
    let mut a: Vec<usize> = (1..=n).collect();
    let mut dir = vec![Dir::Left; n];
    let mut result = vec![a.clone()];

    loop {
        let mut mobile = None;
        for i in 0..n {
            let d = dir[i];
            let adj = match d {
                Dir::Left if i > 0 => Some(i - 1),
                Dir::Right if i < n - 1 => Some(i + 1),
                _ => None,
            };
            if let Some(j) = adj {
                if a[i] > a[j] && (mobile.is_none() || a[i] > a[mobile.unwrap()]) {
                    mobile = Some(i);
                }
            }
        }
        let Some(m) = mobile else { break };
        let d = dir[m];
        let j = if d == Dir::Left { m - 1 } else { m + 1 };
        a.swap(m, j);
        dir.swap(m, j);
        for i in 0..n {
            if a[i] > a[j] { dir[i] = if dir[i] == Dir::Left { Dir::Right } else { Dir::Left }; }
        }
        result.push(a.clone());
    }
    result
}
```

```rust
/// 1.3 Rank a permutation using Lehmer code
pub fn rank_perm(perm: &[usize]) -> usize {
    let n = perm.len();
    let mut used = vec![false; n];
    let mut rank = 0;
    for i in 0..n {
        let count = (0..perm[i]).filter(|&j| !used[j]).count();
        rank = rank * (n - i) + count;
        used[perm[i]] = true;
    }
    rank
}

/// 1.3 Unrank a permutation from its rank
pub fn unrank_perm(n: usize, mut rank: usize) -> Vec<usize> {
    let mut elems: Vec<usize> = (0..n).collect();
    let mut result = vec![0; n];
    for i in 0..n {
        let f = n - i;
        let d = rank % f;
        rank /= f;
        result[i] = elems.remove(d);
    }
    result
}
```

```rust
/// 1.4 Fisherâ€“Yates random permutation
use rand::prelude::*;

pub fn shuffle<T>(arr: &mut [T]) {
    let mut rng = thread_rng();
    for i in (1..arr.len()).rev() {
        let j = rng.gen_range(0..=i);
        arr.swap(i, j);
    }
}
```

---
