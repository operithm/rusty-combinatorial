Here is the full treatment for **Chapter 5 ‚Äì Algorithms for Unlabeled Graphs** from *Combinatorial Algorithms for Computers and Calculators* by Nijenhuis and Wilf.

---

## üìò Chapter 5: Algorithms for Unlabeled Graphs

---

### üîç **Main Ideas**

This chapter addresses generation and enumeration of *unlabeled* simple graphs ‚Äî graphs without vertex names or identity, where isomorphic graphs are considered the same. Key ideas include:

* Canonical forms and isomorphism classes
* Use of adjacency matrices with constraints
* Generation of all unlabeled graphs of ( n ) nodes
* Algorithms for computing automorphism groups
* Graph invariants to distinguish non-isomorphic structures

---

## ‚úÖ **Step 1: Chapter Summary with Algorithm Descriptions**

---

### üîó **5.1 Graph Enumeration**

**Goal**: Generate all distinct (unlabeled) graphs with ( n ) vertices.

**Key Concepts**:

* Labeled graphs: ( 2^{\binom{n}{2}} )
* Unlabeled graphs: much fewer due to isomorphisms

**Method**:

* Represent graphs via canonical adjacency matrices
* Generate canonical representatives by considering lexicographically minimal adjacency strings under all vertex permutations
* Use orderly generation to avoid duplication

**Complexity**: Super-exponential in ( n ), but tractable for ( n \leq 6 )

---

### üß© **5.2 Isomorphism Testing**

**Goal**: Check whether two graphs are isomorphic.

**Method**:

* Try all permutations of vertex labels to match adjacency matrices
* Use invariants (degree sequences, number of edges) for early pruning

**Canonical Labeling**: Assign a unique representation to a graph such that two graphs are isomorphic if and only if their canonical labels match

**Complexity**: Worst-case exponential; fast in practice for small ( n )

---

### üîÑ **5.3 Automorphism Group of a Graph**

**Goal**: Compute the automorphism group of a graph (set of vertex permutations preserving structure).

**Method**:

* Count permutations that map adjacency matrix to itself
* Group theory and search over symmetric group

---

### üìä **5.4 Graph Invariants**

**Goal**: Compute quantities that are preserved under isomorphism.

**Examples**:

* Degree sequence
* Number of edges
* Connected components
* Spectrum of adjacency matrix

**Use**: Quick filtering before full isomorphism check

---

## ‚ú® **Step 2: CLRS-style Abstract Pseudocode**

---

### 5.1 GENERATE-UNLABELED-GRAPHS

```plaintext
GEN-GRAPHS(n)
1. Initialize empty set S
2. for each 0-1 adjacency matrix A of size n
3.     if CANONICAL(A)
4.         add A to S
5. return S
```

---

### 5.2 IS-ISOMORPHIC(G1, G2)

```plaintext
IS-ISOMORPHIC(G1, G2)
1. for each permutation œÄ of vertices
2.     if permute(G1, œÄ) == G2
3.         return true
4. return false
```

---

### 5.3 CANONICAL-LABEL(G)

```plaintext
CANONICAL-LABEL(G)
1. min_label ‚Üê ‚àû
2. for each permutation œÄ of vertices
3.     label ‚Üê serialize(permute(G, œÄ))
4.     if label < min_label
5.         min_label ‚Üê label
6. return min_label
```

---

## ü¶Ä **Step 3: Rust Implementation**

---

### `unlabeled_graphs/generate.rs`

```rust
use itertools::Itertools;

pub fn generate_graphs(n: usize) -> Vec<Vec<Vec<bool>>> {
    let num_edges = n * (n - 1) / 2;
    let mut result = vec![];

    for bits in 0..(1 << num_edges) {
        let mut g = vec![vec![false; n]; n];
        let mut idx = 0;
        for i in 0..n {
            for j in (i + 1)..n {
                if (bits >> idx) & 1 == 1 {
                    g[i][j] = true;
                    g[j][i] = true;
                }
                idx += 1;
            }
        }
        if is_canonical(&g) {
            result.push(g);
        }
    }
    result
}
```

---

### `unlabeled_graphs/isomorphism.rs`

```rust
use itertools::Itertools;

pub fn are_isomorphic(g1: &[Vec<bool>], g2: &[Vec<bool>]) -> bool {
    let n = g1.len();
    for perm in (0..n).permutations(n) {
        let mut match_all = true;
        for i in 0..n {
            for j in 0..n {
                if g1[i][j] != g2[perm[i]][perm[j]] {
                    match_all = false;
                    break;
                }
            }
            if !match_all { break; }
        }
        if match_all {
            return true;
        }
    }
    false
}

pub fn canonical_label(g: &[Vec<bool>]) -> Vec<u8> {
    let n = g.len();
    let mut best = vec![255; n * n];
    for perm in (0..n).permutations(n) {
        let mut label = vec![0; n * n];
        for i in 0..n {
            for j in 0..n {
                label[i * n + j] = g[perm[i]][perm[j]] as u8;
            }
        }
        if label < best {
            best = label;
        }
    }
    best
}
```

---

### ‚úÖ Tests

```rust
#[cfg(test)]
mod tests {
    use super::generate::*;
    use super::isomorphism::*;

    #[test]
    fn test_small_graphs() {
        let graphs = generate_graphs(3);
        assert_eq!(graphs.len(), 4); // 4 unlabeled simple graphs with 3 nodes
    }

    #[test]
    fn test_isomorphism() {
        let g1 = vec![
            vec![false, true, false],
            vec![true, false, true],
            vec![false, true, false],
        ];
        let g2 = vec![
            vec![false, false, true],
            vec![false, false, true],
            vec![true, true, false],
        ];
        assert!(are_isomorphic(&g1, &g2));
    }

    #[test]
    fn test_canonical_label() {
        let g1 = vec![
            vec![false, true, false],
            vec![true, false, true],
            vec![false, true, false],
        ];
        let g2 = vec![
            vec![false, false, true],
            vec![false, false, true],
            vec![true, true, false],
        ];
        assert_eq!(canonical_label(&g1), canonical_label(&g2));
    }
}
```

---
