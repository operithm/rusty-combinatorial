Here is the full treatment for **Chapter 6 ‚Äì Generation of Trees** from *Combinatorial Algorithms for Computers and Calculators** by Nijenhuis and Wilf.

---

## üìò Chapter 6: Generation of Trees

---

### üîç **Main Ideas**

This chapter explores combinatorial generation of various classes of **trees**, particularly:

* Labeled free trees (unrooted, without orientation)
* Rooted trees
* Ordered (plane) trees
* Pr√ºfer codes as a powerful encoding scheme

Each type of tree is treated with specific representations, generation methods, and counting formulas.

---

## ‚úÖ **Step 1: Chapter Summary with Algorithm Descriptions**

---

### üå≥ **6.1 Pr√ºfer Code for Labeled Trees**

**Goal**: Encode and decode labeled trees on ( n ) nodes.

**Key Theorem**: There are exactly ( n^{n-2} ) labeled trees on ( n ) nodes.

**Pr√ºfer Encoding**:

* Repeatedly remove the smallest leaf and record its neighbor.
* Continue until 2 nodes remain.
* Produces a code of length ( n-2 ).

**Decoding**:

* Count occurrences of each node in the code.
* Iteratively connect smallest unused node to first code entry.

**Complexity**: ( O(n \log n) ) with naive implementation; ( O(n) ) with heaps or counting arrays.

---

### üå± **6.2 Rooted Trees**

**Goal**: Generate rooted trees (one node designated as root) of size ( n ).

**Method**:

* Recursive composition: root plus a multiset of subtrees
* Can be encoded via parent array where each node points to its parent

**Counting**: ( T(n) = n^{n-1} ) (Cayley‚Äôs formula for rooted trees)

---

### üß≠ **6.3 Ordered (Plane) Trees**

**Goal**: Generate plane trees: rooted trees where the order of subtrees matters.

**Representation**:

* Can be represented by balanced parenthesis sequences or preorder traversal encodings

**Generation**:

* Recursively attach ordered sequences of subtrees to a root
* Conform to constraints like number of children or depth

---

## ‚ú® **Step 2: CLRS-style Pseudocode**

---

### 6.1 PRUEFER-ENCODE

```plaintext
PRUEFER-ENCODE(T)
1. P ‚Üê empty list
2. while T has more than 2 nodes
3.     leaf ‚Üê smallest leaf node
4.     neighbor ‚Üê node connected to leaf
5.     append neighbor to P
6.     remove leaf from T
7. return P
```

---

### 6.1 PRUEFER-DECODE

```plaintext
PRUEFER-DECODE(P)
1. n ‚Üê length(P) + 2
2. degree ‚Üê [1] * n
3. for x in P:
4.     degree[x] += 1
5. for i in 0 to n - 2:
6.     find j such that degree[j] == 1 and j not in used
7.     append edge (j, P[i])
8.     degree[j] -= 1; degree[P[i]] -= 1
9. return edges
```

---

### 6.2 GENERATE-ROOTED-TREES(n)

```plaintext
GEN-ROOTED-TREES(n)
1. if n == 1: return [singleton tree]
2. for each composition of n-1 into k parts
3.     generate subtrees of sizes in composition
4.     attach subtrees to new root
```

---

## ü¶Ä **Step 3: Rust Implementation**

---

### `trees/pruefer.rs`

```rust
use std::collections::{BTreeSet, VecDeque};

pub fn pruefer_encode(adj: &Vec<Vec<usize>>) -> Vec<usize> {
    let n = adj.len();
    let mut degree = vec![0; n];
    let mut graph = vec![vec![]; n];
    for (u, nbrs) in adj.iter().enumerate() {
        degree[u] = nbrs.len();
        graph[u] = nbrs.clone();
    }

    let mut leaves = BTreeSet::new();
    for (i, &d) in degree.iter().enumerate() {
        if d == 1 {
            leaves.insert(i);
        }
    }

    let mut code = vec![];
    for _ in 0..n - 2 {
        let &leaf = leaves.iter().next().unwrap();
        leaves.remove(&leaf);
        let neighbor = graph[leaf][0];
        code.push(neighbor);

        degree[leaf] -= 1;
        degree[neighbor] -= 1;

        graph[neighbor].retain(|&x| x != leaf);
        if degree[neighbor] == 1 {
            leaves.insert(neighbor);
        }
    }

    code
}
```

---

### `trees/pruefer_decode.rs`

```rust
use std::collections::BinaryHeap;
use std::cmp::Reverse;

pub fn pruefer_decode(code: &[usize]) -> Vec<(usize, usize)> {
    let n = code.len() + 2;
    let mut degree = vec![1; n];
    for &v in code {
        degree[v] += 1;
    }

    let mut leaves = BinaryHeap::new();
    for (i, &d) in degree.iter().enumerate() {
        if d == 1 {
            leaves.push(Reverse(i));
        }
    }

    let mut result = vec![];
    let mut code_iter = code.iter().copied();
    for v in code_iter {
        let Reverse(u) = leaves.pop().unwrap();
        result.push((u, v));
        degree[u] -= 1;
        degree[v] -= 1;
        if degree[v] == 1 {
            leaves.push(Reverse(v));
        }
    }

    let mut remaining = vec![];
    for (i, &d) in degree.iter().enumerate() {
        if d == 1 {
            remaining.push(i);
        }
    }

    result.push((remaining[0], remaining[1]));
    result
}
```

---

### ‚úÖ Tests

```rust
#[cfg(test)]
mod tests {
    use super::pruefer::*;
    use super::pruefer_decode::*;

    #[test]
    fn test_pruefer_encode_decode() {
        let tree = vec![
            vec![1],
            vec![0, 2, 3],
            vec![1],
            vec![1],
        ];
        let code = pruefer_encode(&tree);
        let edges = pruefer_decode(&code);

        // Reconstruct adjacency list from edges
        let mut g = vec![vec![]; 4];
        for (u, v) in edges {
            g[u].push(v);
            g[v].push(u);
        }

        // Check that reconstructed tree has same structure
        let mut deg_orig = tree.iter().map(|v| v.len()).collect::<Vec<_>>();
        let mut deg_new = g.iter().map(|v| v.len()).collect::<Vec<_>>();
        deg_orig.sort();
        deg_new.sort();
        assert_eq!(deg_orig, deg_new);
    }
}
```

---